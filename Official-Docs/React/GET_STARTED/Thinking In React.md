# **Thinking in React**

React로 UI를 구현하기 위해서는 **일반적으로 5가지 단계**를 거친다.

## UI를 컴포넌트 계층으로 쪼개기

디자인 시안을 컴포넌트 단위로 쪼개기 위해선 **다음과 같은 과정**들이 필요하다.

- 디자인 시안에 있는 모든 컴포넌트들과 하위 컴포넌트 주변에 박스를 그리고 이름을 붙여본다.
- 디자이너와 함께 일한다면 특정 컴포넌트에 대해 네이밍이 정해져있는지 물어본다.

컴포넌트 네이밍을 할 땐 **어떤 배경을 가지고 있냐**에 따라서 관점이 달라질 수 있다.

1. Programming - 단일 책임 원칙을 반영하고자 한다면 한번에 한 가지 일만 하도록 해야 한다.

2. CSS - class 선택자를 무엇으로 만들기 고민해본다.

3. Design - 디자인 계층을 어떤 식으로 구성할지 생각해 본다.

**서비스 내 필요한 UI와 데이터 모델은 보통 같은 구조를 가지기 때문**에 **백엔드로 부터 받는 JSON 데이터가 사용자 요구 사항에 맞게 구조화 되어있다면 UI의 컴포넌트 구조는 자연스럽게 데이터 모델에 대응**하는 것을 발견할 수 있다.

UI를 컴포넌트로 분리하고, 각 컴포넌트가 데이터 모델에 매칭 될 수 있도록 신경 써야 한다.

### 예시 : TO DO APP

![image](https://github.com/jinyoung234/FE_Study/assets/87177577/b34bb288-0d5e-4b73-b59d-39877be5d56b)

할 일을 추가 및 체크가 가능한 TO DO 앱이 있다고 가정한다면 컴포넌트를 다음과 같이 쪼개볼 수 있다. 위에서도 언급했지만 여러 방면에서 고려해볼 수 있지만 1번을 중점으로한 각 컴포넌트의 역할을 중점으로 컴포넌트를 다음과 같이 설계 했다.

![image](https://github.com/jinyoung234/FE_Study/assets/87177577/802901b5-0015-44f9-839c-1ab5ebcdb877)

파란색 영역의 컴포넌트를 가장 최상위 부모 컴포넌트, 핑크색 영역의 컴포넌트가 그 다음 부모 컴포넌트, 빨간색 영역의 컴포넌트를 최하위 컴포넌트로 지정했다.

파란색 컴포넌트는 전체적인 TO DO 앱의 Template 역할을 수행하므로 `ToDoTemplate`로 네이밍 했다.

입력 영역의 핑크색 컴포넌트는 유저가 TO DO를 입력하고 추가 하는 기능을 수행하므로 `SearchForm`, 그 밑의 핑크색 컴포넌트는 유저의 할 일 목록을 보여주는 기능을 수행하기에 `TodoList`, TodoList의 단일 컴포넌트인 `TodoListItem`으로 각각 네이밍 했다.

빨간색 컴포넌트들은 위에서 부터 `Heading`, `Input`, `Button`, `CheckBox`, `Text`로 네이밍 했다.

## React로 정적인 버전 구현하기

디자인 시안에 대해 컴포넌트 계층으로 쪼갰다면 앱을 구현해보자.

가장 쉬운 접근 방법은 **Javascript 코드를 추가하지 않은 즉, 데이터 모델로 부터 UI를 렌더링 하는 버전**을 만드는 것이다. **정적인 버전을 만든다는 것은 다른 컴포넌트를 재사용하고 props를 이용해서 데이터를 넘겨주는 컴포넌트를 구현** 하는 것이다.

state 개념에 익숙하더라도 **state는 오직 상호작용을 위한 즉, 데이터가 변경되는 경우에만 사용하기 때문**에 **정적인 버전에는 적합하지 않은 도구**이다.

앱을 만들 땐 `Top-Down` 방식과 `Bottom-Up` 방식이 있지만, `Bottom-Up`은 **만들기 쉬운 장점**이, `Top-Down`은 **테스트를 작성하면서 개발하기 더 쉽다는 장점**이 있다.

이 단계가 끝나면 데이터 렌더링을 위해 만들어진 **재 사용 가능한 컴포넌트들의 라이브러리**를 가지게 된다. 현재는 앱의 정적 버전이므로 컴포넌트는 단순히 JSX만 반환한다.

## 최소한의 데이터만 이용해서 완벽하게 UI State 표현하기

**UI를 상호작용하게 만들려면 사용자가 데이터 모델을 변경**할 수 있게 해야 하며 `React`는 `state`**를 통해 데이터 모델을 변경**할 수 있다.

`state`는 **앱이 기억해야 하는, 변경할 수 있는 데이터의 최소 집합으로 이해**해야 하며, 구조화 하기 위해 **가장 중요한 원칙은 중복배제원칙(DRY 원칙)**이다.

`state`가 될 수 없는 조건은 3가지가 있다.

- 시간이 지나도 변하는가?
- 부모로부터 props를 통해 전달되는 데이터인가?
- 컴포넌트 내 다른 state나 props를 가지고 계산이 가능한가?

이 외의 경우엔 state를 사용할 수 있는 것이다.

## State가 어디에 있어야 할 지 정하기

앱 내 최소한의 state를 결정 했다면 **어떤 컴포넌트가 이 state를 소유하고, 변경할 책임을 지게 할 지 정해야 한다.**

`React`는 **항상 컴포넌트 계층 구조를 따라 부모에서 자식으로 데이터를 전달하는 단방향 데이터 흐름을 사용하는 방식을 채택**하고 있다.

어떤 컴포넌트가 state를 가져야 할지는 **다음과 같은 과정**을 통해 결정할 수 있다.

1. 해당 state를 기반으로 렌더링 되는 컴포넌트를 찾는다.
2. 그들의 가장 가까운 공통되는 부모 컴포넌트를 찾는다. (계층 내 상위 컴포넌트)
3. state가 어디에 위치 돼야 할지 결정한다.
4. 만약 state를 소유할 적절한 컴포넌트를 찾지 못했다면 state를 소유하는 컴포넌트를 만들어서 상위 계층에 추가 한다.

## 역 데이터 흐름 추가하기

4번까지의 과정에서는 props와 state의 함수로써 앱을 만들었다면 이젠 **사용자 입력에 따라 state를 변경하기 위해 반대 방향의 데이터 흐름을 만들어야 한다.** 이를 위해선 **계층 구조의 하단에 있는 컴포넌트에서 부모 컴포넌트의 state를 업데이트** 해야 한다.

`React`는 데이터 흐름을 명시적으로 보이게 만들지만 **양방향 데이터 바인딩 보다 더 많은 타이핑을 필요로 한다.**
